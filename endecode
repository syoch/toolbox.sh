#!/usr/bin/python3

from types import NoneType
import chardet
from typing import Iterable, List, Optional

default_encoding = "SJIS"

kNotSet = -1
kEncode = 0
kDecode = 1
kSetEndian = 2


def try_decode(src: bytes, encoding: str) -> Optional[str]:
    try:
        return src.decode(encoding)
    except:
        return None


class Command:
    def __init__(self, encoding: str, data: str):
        self.encoding = encoding
        self.data = data


class StringIterator:
    def __init__(self, str: str):
        self.str = str

    def peek(self, length: int = 0) -> str:
        return self.str[:length]

    def consume(self, length: int = 0) -> NoneType:
        self.str = self.str[length:]

    def read(self, length: int = 0) -> str:
        ret = self.str[:length]
        self.consume(length)
        return ret

    def starts_with_lower(self, prefix: str) -> bool:
        if self.str.lower().startswith(prefix):
            self.consume(len(prefix))
            return True

        return False

    def is_hex(self) -> bool:
        if all(c.upper() in " 0123456789ABCDEF" for c in self.str):
            return True
        else:
            return False

    def read_until(self, stopper: str) -> str:
        length = self.str.find(stopper)
        ret = self.read(length)
        self.consume(len(stopper))
        return ret

    def get_mode(self):
        if self.starts_with_lower("e"):
            return kEncode
        elif self.starts_with_lower("d"):
            return kDecode
        elif self.starts_with_lower("c"):
            return kSetEndian

        if self.is_hex():
            return kDecode
        else:
            return kEncode


class App:
    def __init__(self):
        self.current_encoding = default_encoding
        self.iter = StringIterator("")

    def get_optional_encoding(self) -> Optional[str]:
        if self.iter.starts_with_lower("/"):
            return self.iter.read_until(" ")
        else:
            return None

    def get_encoding(self):
        encoding = self.get_optional_encoding()
        if encoding:
            return encoding
        else:
            return self.current_encoding

    def get_encodings(self, encoded) -> List[str]:
        encodings = ["utf-8", "SJIS", "euc-jp", "unicode-escape"]
        encodings.append(self.encoding)
        encodings.append(chardet.detect(encoded)["encoding"])
        for bits in [16, 32, 64]:
            for endian in ["be", "le"]:
                encodings.append(f"utf-{bits}-{endian}")

    def try_decode(self, src: bytes, encoding: Optional[str] = None) -> Optional[str]:
        if not encoding:
            encoding = self.current_encoding
        decoded = try_decode(src, encoding)

        if decoded:
            print(f"{encoding} Decoded: {decoded}")
            return True

    def process_command(self, text):
        self.iter = StringIterator(text)
        mode = self.iter.get_mode()

        if mode == kSetEndian:
            self.consume(1)
            self.current_encoding = self.iter.str
            return

        self.encoding = self.get_encoding()

        if mode == kEncode:
            encoded = self.iter.str.encode(self.encoding).hex().upper()
            print(f"{self.encoding} Encode: {encoded}")
        elif mode == kDecode:
            if not self.iter.is_hex():
                print("Decode: Invalid hex string")
                return

            encoded = bytes.fromhex(self.iter.str)

            for encoding in set(self.get_encodings()):
                self.try_decode(encoded, encoding)

    def process_line(self):
        text = input(f"(char conv [{self.current_encoding}]) >>> ")
        self.process_command(text)


app = App()
while True:
    app.process_line()
